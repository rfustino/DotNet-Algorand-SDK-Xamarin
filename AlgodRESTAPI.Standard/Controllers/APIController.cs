/*
 * AlgodRESTAPI.Standard
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
using System;
using System.Collections.Generic;
using System.Dynamic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json.Converters;
using AlgodRESTAPI.Standard;
using AlgodRESTAPI.Standard.Utilities;
using AlgodRESTAPI.Standard.Http.Request;
using AlgodRESTAPI.Standard.Http.Response;
using AlgodRESTAPI.Standard.Http.Client;
using AlgodRESTAPI.Standard.Exceptions;

namespace AlgodRESTAPI.Standard.Controllers
{
    public partial class APIController: BaseController
    {
        #region Singleton Pattern

        //private static variables for the singleton pattern
        private static object syncObject = new object();
        private static APIController instance = null;

        /// <summary>
        /// Singleton pattern implementation
        /// </summary>
        internal static APIController Instance
        {
            get
            {
                lock (syncObject)
                {
                    if (null == instance)
                    {
                        instance = new APIController();
                    }
                }
                return instance;
            }
        }

        #endregion Singleton Pattern

        /// <summary>
        /// Returns OK if healthy.
        /// </summary>
        /// <return>Returns the void response from the API call</return>
        public void GetHealthCheck()
        {
            Task t = GetHealthCheckAsync();
            APIHelper.RunTaskSynchronously(t);
        }

        /// <summary>
        /// Returns OK if healthy.
        /// </summary>
        /// <return>Returns the void response from the API call</return>
        public async Task GetHealthCheckAsync()
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/health");


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if (_response.StatusCode == 404)
                throw new APIException(@"Not Found", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

        }

        /// <summary>
        /// Return metrics about algod functioning.
        /// </summary>
        /// <return>Returns the void response from the API call</return>
        public void GetMetrics()
        {
            Task t = GetMetricsAsync();
            APIHelper.RunTaskSynchronously(t);
        }

        /// <summary>
        /// Return metrics about algod functioning.
        /// </summary>
        /// <return>Returns the void response from the API call</return>
        public async Task GetMetricsAsync()
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/metrics");


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 404)
                throw new APIException(@"metrics were compiled out", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

        }

        /// <summary>
        /// Returns the entire swagger spec in json.
        /// </summary>
        /// <return>Returns the string response from the API call</return>
        public string GetSwaggerJSON()
        {
            Task<string> t = GetSwaggerJSONAsync();
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Returns the entire swagger spec in json.
        /// </summary>
        /// <return>Returns the string response from the API call</return>
        public async Task<string> GetSwaggerJSONAsync()
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/swagger.json");


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return _response.Body;
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Given a specific account public key, this call returns the accounts status, balance and spendable amounts
        /// </summary>
        /// <param name="address">Required parameter: An account public key</param>
        /// <return>Returns the Models.Account response from the API call</return>
        public Models.Account GetAccountInformation(string address)
        {
            Task<Models.Account> t = GetAccountInformationAsync(address);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Given a specific account public key, this call returns the accounts status, balance and spendable amounts
        /// </summary>
        /// <param name="address">Required parameter: An account public key</param>
        /// <return>Returns the Models.Account response from the API call</return>
        public async Task<Models.Account> GetAccountInformationAsync(string address)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/v1/account/{address}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "address", address }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 400)
                throw new APIException(@"Bad Request", _context);

            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if (_response.StatusCode == 500)
                throw new APIException(@"Internal Error", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Account>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Given a wallet address and a transaction id, it returns the confirmed transaction information. This call scans up to <CurrentProtocol>.MaxTxnLife blocks in the past.
        /// </summary>
        /// <param name="address">Required parameter: An account public key</param>
        /// <param name="txid">Required parameter: A transaction id</param>
        /// <return>Returns the Models.Transaction response from the API call</return>
        public Models.Transaction GetTransactionInformation(string address, string txid)
        {
            Task<Models.Transaction> t = GetTransactionInformationAsync(address, txid);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Given a wallet address and a transaction id, it returns the confirmed transaction information. This call scans up to <CurrentProtocol>.MaxTxnLife blocks in the past.
        /// </summary>
        /// <param name="address">Required parameter: An account public key</param>
        /// <param name="txid">Required parameter: A transaction id</param>
        /// <return>Returns the Models.Transaction response from the API call</return>
        public async Task<Models.Transaction> GetTransactionInformationAsync(string address, string txid)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/v1/account/{address}/transaction/{txid}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "address", address },
                { "txid", txid }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 400)
                throw new APIException(@"Bad Request", _context);

            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if (_response.StatusCode == 404)
                throw new APIException(@"Transaction Not Found", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Transaction>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Returns the list of confirmed transactions between within a date range. This call is available only when the indexer is running.
        /// </summary>
        /// <param name="address">Required parameter: An account public key</param>
        /// <param name="firstRound">Optional parameter: Do not fetch any transactions before this round.</param>
        /// <param name="lastRound">Optional parameter: Do not fetch any transactions after this round.</param>
        /// <param name="fromDate">Optional parameter: Do not fetch any transactions before this date. (enabled only with indexer)</param>
        /// <param name="toDate">Optional parameter: Do not fetch any transactions after this date. (enabled only with indexer)</param>
        /// <param name="max">Optional parameter: maximum transactions to show (default to 100)</param>
        /// <return>Returns the Models.TransactionList response from the API call</return>
        public Models.TransactionList GetTransactions(
                string address,
                long? firstRound = null,
                long? lastRound = null,
                DateTime? fromDate = null,
                DateTime? toDate = null,
                long? max = null)
        {
            Task<Models.TransactionList> t = GetTransactionsAsync(address, firstRound, lastRound, fromDate, toDate, max);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Returns the list of confirmed transactions between within a date range. This call is available only when the indexer is running.
        /// </summary>
        /// <param name="address">Required parameter: An account public key</param>
        /// <param name="firstRound">Optional parameter: Do not fetch any transactions before this round.</param>
        /// <param name="lastRound">Optional parameter: Do not fetch any transactions after this round.</param>
        /// <param name="fromDate">Optional parameter: Do not fetch any transactions before this date. (enabled only with indexer)</param>
        /// <param name="toDate">Optional parameter: Do not fetch any transactions after this date. (enabled only with indexer)</param>
        /// <param name="max">Optional parameter: maximum transactions to show (default to 100)</param>
        /// <return>Returns the Models.TransactionList response from the API call</return>
        public async Task<Models.TransactionList> GetTransactionsAsync(
                string address,
                long? firstRound = null,
                long? lastRound = null,
                DateTime? fromDate = null,
                DateTime? toDate = null,
                long? max = null)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/v1/account/{address}/transactions");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "address", address }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "firstRound", firstRound },
                { "lastRound", lastRound },
                { "fromDate", (fromDate.HasValue) ? fromDate.Value.ToString("yyyy'-'MM'-'dd") : null },
                { "toDate", (toDate.HasValue) ? toDate.Value.ToString("yyyy'-'MM'-'dd") : null },
                { "max", max }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 400)
                throw new APIException(@"Bad Request", _context);

            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if (_response.StatusCode == 500)
                throw new APIException(@"Internal Error", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.TransactionList>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get the list of pending transactions by address, sorted by priority, in decreasing order, truncated at the end at MAX. If MAX = 0, returns all pending transactions.
        /// </summary>
        /// <param name="addr">Required parameter: An account public key</param>
        /// <param name="max">Optional parameter: Truncated number of transactions to display. If max=0, returns all pending txns.</param>
        /// <return>Returns the Models.PendingTransactions response from the API call</return>
        public Models.PendingTransactions GetPendingTransactionsByAddress(string addr, long? max = null)
        {
            Task<Models.PendingTransactions> t = GetPendingTransactionsByAddressAsync(addr, max);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get the list of pending transactions by address, sorted by priority, in decreasing order, truncated at the end at MAX. If MAX = 0, returns all pending transactions.
        /// </summary>
        /// <param name="addr">Required parameter: An account public key</param>
        /// <param name="max">Optional parameter: Truncated number of transactions to display. If max=0, returns all pending txns.</param>
        /// <return>Returns the Models.PendingTransactions response from the API call</return>
        public async Task<Models.PendingTransactions> GetPendingTransactionsByAddressAsync(string addr, long? max = null)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/v1/account/{addr}/transactions/pending");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "addr", addr }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "max", max }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if (_response.StatusCode == 500)
                throw new APIException(@"Internal Error", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.PendingTransactions>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Given the asset's unique index, this call returns the asset's creator, manager, reserve, freeze, and clawback addresses
        /// </summary>
        /// <param name="index">Required parameter: Asset index</param>
        /// <return>Returns the Models.AssetParamsSpecifiesTheParametersForAnAsset response from the API call</return>
        public Models.AssetParamsSpecifiesTheParametersForAnAsset GetAssetInformation(long index)
        {
            Task<Models.AssetParamsSpecifiesTheParametersForAnAsset> t = GetAssetInformationAsync(index);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Given the asset's unique index, this call returns the asset's creator, manager, reserve, freeze, and clawback addresses
        /// </summary>
        /// <param name="index">Required parameter: Asset index</param>
        /// <return>Returns the Models.AssetParamsSpecifiesTheParametersForAnAsset response from the API call</return>
        public async Task<Models.AssetParamsSpecifiesTheParametersForAnAsset> GetAssetInformationAsync(long index)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/v1/asset/{index}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "index", index }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 400)
                throw new APIException(@"Bad Request", _context);

            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if (_response.StatusCode == 500)
                throw new APIException(@"Internal Error", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.AssetParamsSpecifiesTheParametersForAnAsset>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Returns list of up to `max` assets, where the maximum assetIdx is <= `assetIdx`
        /// </summary>
        /// <param name="assetIdx">Optional parameter: Fetch assets with asset index <= assetIdx. If zero, fetch most recent assets.</param>
        /// <param name="max">Optional parameter: Fetch no more than this many assets</param>
        /// <return>Returns the Models.AssetList response from the API call</return>
        public Models.AssetList GetAssets(long? assetIdx = null, long? max = null)
        {
            Task<Models.AssetList> t = GetAssetsAsync(assetIdx, max);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Returns list of up to `max` assets, where the maximum assetIdx is <= `assetIdx`
        /// </summary>
        /// <param name="assetIdx">Optional parameter: Fetch assets with asset index <= assetIdx. If zero, fetch most recent assets.</param>
        /// <param name="max">Optional parameter: Fetch no more than this many assets</param>
        /// <return>Returns the Models.AssetList response from the API call</return>
        public async Task<Models.AssetList> GetAssetsAsync(long? assetIdx = null, long? max = null)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/v1/assets");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "assetIdx", assetIdx },
                { "max", max }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 400)
                throw new APIException(@"Bad Request", _context);

            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if (_response.StatusCode == 500)
                throw new APIException(@"Internal Error", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.AssetList>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get the block for the given round.
        /// </summary>
        /// <param name="round">Required parameter: The round from which to fetch block information.</param>
        /// <return>Returns the Models.Block response from the API call</return>
        public Models.Block GetBlock(long round)
        {
            Task<Models.Block> t = GetBlockAsync(round);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get the block for the given round.
        /// </summary>
        /// <param name="round">Required parameter: The round from which to fetch block information.</param>
        /// <return>Returns the Models.Block response from the API call</return>
        public async Task<Models.Block> GetBlockAsync(long round)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/v1/block/{round}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "round", round }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 400)
                throw new APIException(@"Bad Request", _context);

            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if (_response.StatusCode == 500)
                throw new APIException(@"Internal Error", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Block>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get the current supply reported by the ledger.
        /// </summary>
        /// <return>Returns the Models.Supply response from the API call</return>
        public Models.Supply GetSupply()
        {
            Task<Models.Supply> t = GetSupplyAsync();
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get the current supply reported by the ledger.
        /// </summary>
        /// <return>Returns the Models.Supply response from the API call</return>
        public async Task<Models.Supply> GetSupplyAsync()
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/v1/ledger/supply");


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Supply>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Gets the current node status.
        /// </summary>
        /// <return>Returns the Models.NodeStatus response from the API call</return>
        public Models.NodeStatus GetStatus()
        {
            Task<Models.NodeStatus> t = GetStatusAsync();
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Gets the current node status.
        /// </summary>
        /// <return>Returns the Models.NodeStatus response from the API call</return>
        public async Task<Models.NodeStatus> GetStatusAsync()
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/v1/status");


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if (_response.StatusCode == 500)
                throw new APIException(@"Internal Error", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.NodeStatus>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Waits for a block to appear after round {round} and returns the node's status at the time.
        /// </summary>
        /// <param name="round">Required parameter: The round to wait until returning status</param>
        /// <return>Returns the Models.NodeStatus response from the API call</return>
        public Models.NodeStatus GetWaitForBlock(long round)
        {
            Task<Models.NodeStatus> t = GetWaitForBlockAsync(round);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Waits for a block to appear after round {round} and returns the node's status at the time.
        /// </summary>
        /// <param name="round">Required parameter: The round to wait until returning status</param>
        /// <return>Returns the Models.NodeStatus response from the API call</return>
        public async Task<Models.NodeStatus> GetWaitForBlockAsync(long round)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/v1/status/wait-for-block-after/{round}/");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "round", round }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 400)
                throw new APIException(@"Bad Request", _context);

            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if (_response.StatusCode == 500)
                throw new APIException(@"Internal Error", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.NodeStatus>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Returns the transaction information of the given txid. Works only if the indexer is enabled.
        /// </summary>
        /// <param name="txid">Required parameter: A transaction id</param>
        /// <return>Returns the Models.Transaction response from the API call</return>
        public Models.Transaction GetTransaction(string txid)
        {
            Task<Models.Transaction> t = GetTransactionAsync(txid);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Returns the transaction information of the given txid. Works only if the indexer is enabled.
        /// </summary>
        /// <param name="txid">Required parameter: A transaction id</param>
        /// <return>Returns the Models.Transaction response from the API call</return>
        public async Task<Models.Transaction> GetTransactionAsync(string txid)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/v1/transaction/{txid}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "txid", txid }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 400)
                throw new APIException(@"Bad Request", _context);

            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if (_response.StatusCode == 404)
                throw new APIException(@"Transaction Not Found", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Transaction>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Broadcasts a raw transaction to the network.
        /// </summary>
        /// <param name="rawtxn">Required parameter: The byte encoded signed transaction to broadcast to network</param>
        /// <return>Returns the Models.TransactionID response from the API call</return>
        public Models.TransactionID CreateRawTransaction(FileStreamInfo rawtxn)
        {
            Task<Models.TransactionID> t = CreateRawTransactionAsync(rawtxn);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Broadcasts a raw transaction to the network.
        /// </summary>
        /// <param name="rawtxn">Required parameter: The byte encoded signed transaction to broadcast to network</param>
        /// <return>Returns the Models.TransactionID response from the API call</return>
        public async Task<Models.TransactionID> CreateRawTransactionAsync(FileStreamInfo rawtxn)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/v1/transactions");


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //append form/field parameters
            var _fields = new List<KeyValuePair<string, Object>>()
            {
                new KeyValuePair<string, object>( "rawtxn", rawtxn)
            };
            //remove null parameters
            _fields = _fields.Where(kvp => kvp.Value != null).ToList();

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Post(_queryUrl, _headers, _fields);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 400)
                throw new APIException(@"Bad Request", _context);

            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if (_response.StatusCode == 500)
                throw new APIException(@"Internal Error", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.TransactionID>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Suggested Fee is returned in units of micro-Algos per byte. Suggested Fee may fall to zero but submitted transactions must still have a fee of at least MinTxnFee for the current network protocol.
        /// </summary>
        /// <return>Returns the Models.TransactionFee response from the API call</return>
        public Models.TransactionFee GetSuggestedFee()
        {
            Task<Models.TransactionFee> t = GetSuggestedFeeAsync();
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Suggested Fee is returned in units of micro-Algos per byte. Suggested Fee may fall to zero but submitted transactions must still have a fee of at least MinTxnFee for the current network protocol.
        /// </summary>
        /// <return>Returns the Models.TransactionFee response from the API call</return>
        public async Task<Models.TransactionFee> GetSuggestedFeeAsync()
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/v1/transactions/fee");


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.TransactionFee>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get parameters for constructing a new transaction
        /// </summary>
        /// <return>Returns the Models.TransactionParams response from the API call</return>
        public Models.TransactionParams GetTransactionParams()
        {
            Task<Models.TransactionParams> t = GetTransactionParamsAsync();
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get parameters for constructing a new transaction
        /// </summary>
        /// <return>Returns the Models.TransactionParams response from the API call</return>
        public async Task<Models.TransactionParams> GetTransactionParamsAsync()
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/v1/transactions/params");


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.TransactionParams>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get the list of pending transactions, sorted by priority, in decreasing order, truncated at the end at MAX. If MAX = 0, returns all pending transactions.
        /// </summary>
        /// <param name="max">Optional parameter: Truncated number of transactions to display. If max=0, returns all pending txns.</param>
        /// <return>Returns the Models.PendingTransactions response from the API call</return>
        public Models.PendingTransactions GetPendingTransactions(long? max = null)
        {
            Task<Models.PendingTransactions> t = GetPendingTransactionsAsync(max);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get the list of pending transactions, sorted by priority, in decreasing order, truncated at the end at MAX. If MAX = 0, returns all pending transactions.
        /// </summary>
        /// <param name="max">Optional parameter: Truncated number of transactions to display. If max=0, returns all pending txns.</param>
        /// <return>Returns the Models.PendingTransactions response from the API call</return>
        public async Task<Models.PendingTransactions> GetPendingTransactionsAsync(long? max = null)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/v1/transactions/pending");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "max", max }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if (_response.StatusCode == 500)
                throw new APIException(@"Internal Error", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.PendingTransactions>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Given a transaction id of a recently submitted transaction, it returns information about it.  There are several cases when this might succeed:
        /// - transaction committed (committed round > 0) - transaction still in the pool (committed round = 0, pool error = "") - transaction removed from pool due to error (committed round = 0, pool error != "")
        /// Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error.
        /// </summary>
        /// <param name="txid">Required parameter: A transaction id</param>
        /// <return>Returns the Models.Transaction response from the API call</return>
        public Models.Transaction GetPendingTransactionInformation(string txid)
        {
            Task<Models.Transaction> t = GetPendingTransactionInformationAsync(txid);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Given a transaction id of a recently submitted transaction, it returns information about it.  There are several cases when this might succeed:
        /// - transaction committed (committed round > 0) - transaction still in the pool (committed round = 0, pool error = "") - transaction removed from pool due to error (committed round = 0, pool error != "")
        /// Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error.
        /// </summary>
        /// <param name="txid">Required parameter: A transaction id</param>
        /// <return>Returns the Models.Transaction response from the API call</return>
        public async Task<Models.Transaction> GetPendingTransactionInformationAsync(string txid)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/v1/transactions/pending/{txid}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "txid", txid }
            });


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if (_response.StatusCode == 400)
                throw new APIException(@"Bad Request", _context);

            if (_response.StatusCode == 401)
                throw new APIException(@"Invalid API Token", _context);

            if (_response.StatusCode == 404)
                throw new APIException(@"Transaction Not Found", _context);

            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unknown Error", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Transaction>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Retrieves the current version
        /// </summary>
        /// <return>Returns the Models.VersionContainsTheCurrentAlgodVersion response from the API call</return>
        public Models.VersionContainsTheCurrentAlgodVersion GetVersion()
        {
            Task<Models.VersionContainsTheCurrentAlgodVersion> t = GetVersionAsync();
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Retrieves the current version
        /// </summary>
        /// <return>Returns the Models.VersionContainsTheCurrentAlgodVersion response from the API call</return>
        public async Task<Models.VersionContainsTheCurrentAlgodVersion> GetVersionAsync()
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/versions");


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };
            _headers.Add("X-Algo-API-Token", Configuration.XAlgoAPIToken);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);
            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.VersionContainsTheCurrentAlgodVersion>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

    }
} 